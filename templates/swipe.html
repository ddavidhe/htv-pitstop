<!DOCTYPE html>
<html>
<head>
    <title>PitStop - Swipe Topics</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='swipe.css') }}">
</head>
<body>
    <div class="container swipe-container">
        <h1>Rate Your Knowledge</h1>
        <p class="swipe-instructions">Swipe left if you're weak at this topic, right if you're familiar</p>
        
        <div class="card-stack" id="cardStack">
            {% for topic in topics %}
            <div class="topic-card" data-topic="{{ topic }}">
                <h2>{{ topic }}</h2>
                <div class="swipe-hints">
                    <span class="weak">ðŸ˜° Weak</span>
                    <span class="familiar">ðŸ˜Ž Familiar</span>
                </div>
            </div>
            {% endfor %}
        </div>
        
        <div class="swipe-buttons">
            <button class="swipe-btn weak-btn" onclick="swipeCard('weak')">ðŸ‘ˆ Weak</button>
            <button class="swipe-btn familiar-btn" onclick="swipeCard('familiar')">ðŸ‘‰ Familiar</button>
        </div>
        
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
        
        <div id="completed" class="completed" style="display: none;">
            <h2>Great! We've got your preferences</h2>
            <a href="/" class="upload-btn">Back to Home</a>
        </div>
    </div>

    <script>
        let currentCard = 0;
        let swipeResults = [];
        const cards = document.querySelectorAll('.topic-card');
        const totalCards = cards.length;
        
        // Drag variables
        let isDragging = false;
        let startX = 0;
        let currentX = 0;
        let cardBeingDragged = null;

        function updateProgress() {
            const progress = (currentCard / totalCards) * 100;
            document.getElementById('progress').style.width = progress + '%';
        }

        function showCards() {
            cards.forEach((card, index) => {
                card.classList.remove('current', 'next', 'hidden');

                if (index == currentCard) {
                    card.classList.add('current');
                } else if (index == 1 + currentCard) {
                    card.classList.add('next');
                } else {
                    card.classList.add('hidden');
                }
            });
        }

        // Mouse events
        function handleMouseDown(e) {
            if (currentCard >= totalCards) return;
            
            isDragging = true;
            cardBeingDragged = cards[currentCard];
            startX = e.clientX;
            
            cardBeingDragged.style.cursor = 'grabbing';
            cardBeingDragged.style.transition = 'none';
        }

        function handleMouseMove(e) {
            if (!isDragging || !cardBeingDragged) return;
            
            currentX = e.clientX;
            const deltaX = currentX - startX;
            
            // Move card with mouse
            cardBeingDragged.style.transform = `translateX(${deltaX}px) rotate(${deltaX * 0.1}deg)`;
            
            // Update opacity based on drag distance
            const opacity = Math.max(0.3, 1 - Math.abs(deltaX) / 300);
            cardBeingDragged.style.opacity = opacity;
            
            // Show hints based on direction
            const weakHint = cardBeingDragged.querySelector('.weak');
            const familiarHint = cardBeingDragged.querySelector('.familiar');
            
            if (deltaX < -50) {
                weakHint.style.opacity = Math.min(1, Math.abs(deltaX) / 100);
                familiarHint.style.opacity = 0.3;
            } else if (deltaX > 50) {
                familiarHint.style.opacity = Math.min(1, deltaX / 100);
                weakHint.style.opacity = 0.3;
            } else {
                weakHint.style.opacity = 0.6;
                familiarHint.style.opacity = 0.6;
            }
        }

        function handleMouseUp(e) {
            if (!isDragging || !cardBeingDragged) return;
            
            const deltaX = currentX - startX;
            const threshold = 100; // Minimum drag distance to trigger swipe
            
            if (Math.abs(deltaX) > threshold) {
                // Determine swipe direction
                const rating = deltaX < 0 ? 'weak' : 'familiar';
                
                // Animate card off screen
                const exitX = deltaX < 0 ? -400 : 400;
                cardBeingDragged.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
                cardBeingDragged.style.transform = `translateX(${exitX}px) rotate(${exitX * 0.1}deg)`;
                cardBeingDragged.style.opacity = 0;
                
                // Process the swipe
                processSwipe(rating);
            } else {
                // Snap back to center if not dragged far enough
                cardBeingDragged.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
                cardBeingDragged.style.transform = 'translateX(0px) rotate(0deg)';
                cardBeingDragged.style.opacity = 1;
                
                // Reset hints
                const weakHint = cardBeingDragged.querySelector('.weak');
                const familiarHint = cardBeingDragged.querySelector('.familiar');
                weakHint.style.opacity = 0.6;
                familiarHint.style.opacity = 0.6;
            }
            
            // Reset drag state
            isDragging = false;
            cardBeingDragged.style.cursor = 'grab';
            cardBeingDragged = null;
        }

        function processSwipe(rating) {
            const card = cards[currentCard];
            const topic = card.dataset.topic;
            
            swipeResults.push({
                topic: topic,
                rating: rating
            });

            setTimeout(() => {
                // Hide the swiped card
                card.classList.add('hidden');
                card.style.transform = '';
                card.style.opacity = '';
                card.style.transition = '';
                
                currentCard++;
                updateProgress();

                if (currentCard >= totalCards) {
                    // All cards swiped
                    document.getElementById('completed').style.display = 'block';
                    document.querySelector('.swipe-buttons').style.display = 'none';
                    
                    // Send results to backend
                    fetch('/swipe_result', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(swipeResults)
                    });
                } else {
                    // Promote next card
                    if (currentCard < totalCards) {
                        cards[currentCard].classList.remove('next');
                        cards[currentCard].classList.add('current');
                    }

                    setTimeout(() => {
                        if (currentCard + 1 < totalCards) {
                            cards[currentCard + 1].classList.remove('hidden');
                            cards[currentCard + 1].classList.add('next');
                    }}, 100);
                }
            }, 300);
        }

        // Button fallback (keep for accessibility)
        function swipeCard(rating) {
            if (currentCard >= totalCards) return;

            const card = cards[currentCard];
            
            // Animate with button
            card.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
            card.style.transform = rating === 'weak' ? 'translateX(-400px)' : 'translateX(400px)';
            card.style.opacity = '0';

            processSwipe(rating);
        }

        // Add event listeners
        document.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);

        // Touch events for mobile
        document.addEventListener('touchstart', (e) => {
            e.clientX = e.touches[0].clientX;
            handleMouseDown(e);
        });

        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            e.clientX = e.touches[0].clientX;
            handleMouseMove(e);
        });

        document.addEventListener('touchend', (e) => {
            handleMouseUp(e);
        });

        // Initialize
        showCards();
        updateProgress();
    </script>
</body>
</html>